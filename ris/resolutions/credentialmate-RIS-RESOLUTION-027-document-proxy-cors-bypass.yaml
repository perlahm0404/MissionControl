---
resolution_id: RIS-RESOLUTION-027
title: Document Proxy Endpoint for CORS Bypass (ATTEMPTED - NOT WORKING)
status: attempted_failed
priority: high
date_created: 2025-12-02
date_resolved: null
category: architecture
lane: backend + frontend
risk_level: medium

problem:
  description: |
    PNG/image documents failed to load in browser with CORS policy errors.
    Frontend was loading images directly from LocalStack S3 (localhost:4566) with
    crossOrigin="anonymous" attribute. LocalStack doesn't send proper CORS headers
    for cross-origin requests, blocking image display.

  impact:
    - Users cannot view PNG/image documents in review page
    - CORS errors in browser console
    - Document verification blocked

  root_cause: |
    - Direct S3 access from browser requires CORS configuration
    - LocalStack S3 doesn't reliably support CORS in dev environment
    - `<img crossOrigin="anonymous">` requires CORS headers from server
    - Production S3 could have same issue if CORS misconfigured

attempted_solution:
  approach: Backend Proxy with Blob URL
  description: |
    ATTEMPTED to create proxy endpoint that streams document content through backend API,
    eliminating CORS issues by making all requests same-origin.

    **FIX STATUS: NOT WORKING** - Code changes made but CORS errors still present after testing.

  implementation:
    backend:
      - endpoint: GET /api/v1/documents/{document_id}/view
        file: apps/backend-api/src/api/v1/documents.py
        lines: 452-515
        features:
          - Fetches file from S3 via S3Service.download_file()
          - Returns StreamingResponse with proper Content-Type
          - Sets Content-Disposition: inline for browser viewing
          - Includes Cache-Control headers for performance
          - Enforces provider-level isolation (NPI-first)

    frontend:
      - file: apps/frontend-web/src/app/dashboard/documents/[id]/review/page.tsx
        lines: 251-273
        changes:
          - Fetch document with Authorization header via fetch()
          - Convert response to Blob
          - Create blob URL with URL.createObjectURL()
          - Set blob URL as img src (no CORS needed)
          - Removed crossOrigin="anonymous" attribute

  code_pattern: |
    # Backend (FastAPI)
    @router.get("/{document_id}/view")
    async def view_document(document_id: str, current_user: User, db: Session):
        # Verify access (RLS filtering)
        document = db.query(Document).filter(...).first()

        # Download from S3
        s3_service = S3Service()
        file_content = s3_service.download_file(key=document.s3_key)

        # Stream to client
        return StreamingResponse(
            io.BytesIO(file_content),
            media_type=document.content_type,
            headers={"Content-Disposition": f'inline; filename="{document.original_filename}"'}
        )

    # Frontend (React/TypeScript)
    const response = await fetch(`${API_URL}/documents/${id}/view`, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    const blob = await response.blob();
    const blobUrl = URL.createObjectURL(blob);
    setPreviewUrl(blobUrl);

    // Use blob URL in img tag (no CORS issues)
    <img src={blobUrl} />

alternatives_considered:
  - option: Configure CORS on LocalStack S3
    rejected_reason: |
      Unreliable in dev environment, doesn't match production S3 behavior,
      requires coordination between S3 and API CORS configs

  - option: Use presigned URLs only
    rejected_reason: |
      Still requires CORS headers from S3, doesn't solve cross-origin issue,
      img tag can't send custom headers

  - option: Base64 encode images in API response
    rejected_reason: |
      Poor performance for large images, increases payload size significantly,
      high memory usage for encoding/decoding

trade_offs:
  pros:
    - Works consistently across all environments (dev, staging, prod)
    - No CORS configuration needed on S3
    - Maintains authentication via backend (more secure)
    - Blob URL eliminates CORS entirely (same-origin)
    - Pattern works for PDFs and other file types too

  cons:
    - Backend serves file content (slight performance overhead)
    - Increased backend memory usage for large files
    - Extra network hop (browser → backend → S3 → backend → browser)
    - Blob URLs consume browser memory until revoked

validation:
  test_method: Manual testing with Dr. Sehgal account
  test_document: b1071d8c-5b80-458a-a875-1b6d8ed18fce (NetCE(2).png)
  results:
    - before: CORS error, image failed to load
    - after: **STILL FAILING** - CORS errors still present
    - user_feedback: "png view is not fixed"
    - user_action: Performed hard reset and tested
    - console: CORS errors still appearing
    - no_cors_errors: false
    - status: **FIX DID NOT WORK**

  what_was_tried:
    - Created backend proxy endpoint (code written in documents.py lines 452-515)
    - Modified frontend to fetch as blob (code written in page.tsx lines 251-273)
    - Rebuilt frontend Docker image
    - Restarted frontend container
    - Removed crossOrigin="anonymous" from img tag

  why_it_failed:
    possible_causes:
      - Frontend build may not have included changes
      - Blob URL approach may have authorization issues
      - Proxy endpoint may not be working correctly
      - Browser cache may be serving old code
      - Need actual testing with real PNG file in S3 (file may be missing)

  needs_investigation: true

lessons_learned:
  - Direct S3 access from browser always requires CORS consideration
  - Proxy pattern THEORY is sound, but implementation requires careful testing
  - Code changes alone are not sufficient - must verify fix works in browser
  - Frontend rebuild required when running in production mode (next start)
  - **CRITICAL**: Always test fix with user before documenting as "implemented"
  - Fix validation must include actual browser testing, not just code review

related:
  sessions:
    - SESSION-20251202-PNG-VIEWER-FIX-NPI-FIRST.md

  issues:
    - PNG viewer CORS error blocking document review

  patterns:
    - Backend proxy for external resources (S3, APIs)
    - Blob URL for secure file display
    - StreamingResponse for file serving

tags:
  - cors
  - s3
  - images
  - proxy
  - security
  - frontend
  - backend
  - blob-url
  - streaming

status: attempted_failed
next_steps:
  - **CRITICAL**: Debug why proxy endpoint approach failed
  - Test proxy endpoint directly with curl/PowerShell
  - Verify frontend build included the code changes
  - Check browser network tab for actual requests being made
  - Test with real PNG file in S3 (current test file may be missing)
  - Consider alternative approaches if proxy doesn't work
  - Once working: Add CDN/caching layer for production performance
  - Once working: Implement blob URL cleanup (URL.revokeObjectURL)
  - Once working: Monitor backend memory usage with large files
